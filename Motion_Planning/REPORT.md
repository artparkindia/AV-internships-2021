<center><h1>Path Planning and Tracking of Wheeled Robots</h1></center>
<center><h2>Sakshay Mahna</h2></center>
<center><h2>Internship Report</h2></center>

## Abstract

Motion Planning is a computational problem to find a sequence of valid configurations to move a robot from a start state to an end state. Motion planning algorithms can be applied to wide range of robots, like industrial robots, wheeled robots, aerial robots and autonomous cars.

In this work, a complete Path Planning and tracking system has been developed for use with wheeled robots. A suite of algorithms is provided with adjustable parameters to benchmark and study their efficiency and performance on various test maps. Some comparision of these algorithms have been provided as well.

## Introduction
In this work, we divide the Motion Planning problem, hierarchically as: Global Path Planning, Locally-Smooth Trajectory Planning and Trajectory Tracking.

Global Path Planning involves the task of planning an obstacle free path (a set of points) from a start position to an end position without taking into account, the constraints on velocity, acceleration, curvature, and so on. A\*, RRT, D* are some of the examples of such Path Planning algorithms. 
Locally-Smooth Trajectory Planning involves the task of interpolating and smoothening the path (a set of poses) generated by the path planner. This module also introduces constraints on initial and final yaw of the robot. The path can be interpolated using Splines of varying degrees - linear, cubic, quintic and so on. While we use splines in this work, polynomial spirals can also be used to generate smooth local paths. In effect, the curvature is a smooth higher-order polynomial. The boundary conditions produces the local trajectory of interest.
Trajectory Planning involves the task of generating a time schedule to follow a path given constraints such as position, velocity and acceleration. Frenet Frame algorithm and Model-Predictive control are the algorithms we study in this work.

In this report, a complete motion planning pipeline has been developed. Along with this, a benchmarking tool has also been developed to compare different combinations of algorithms and the effect of the hyper-parameters of these algorithms on different maps. 

## Path Planning Algorithms
Given a map of the environment along with the start and end positions, path planning algorithms determine the shortest route between those two points, avoiding all static obstacles.
A lattice-grid graph is generated to represent the occupancy map of the robot's environment. The nodes of the graph can be connected in a 4-way or 8-way model with adjustable weights of the edges. The path planning algorithm is executed on the grid-graph; the shortest path from source to destination is computed. The pseudocode of some algorithms are discussed next.

All the path planning algorithms follow the same algorithm structure with a difference in how their cost function(`f(n)`) is calculated. The differences in the cost function is discussed further.

### Algorithm

1. Initialize the following to store different nodes
    * Priority Queue (minimum given more priority) with the starting node and cost function `f(n) = 0`
    * Closed List with 0 elements
2. While the goal node is not reached,
    * Select the minimum cost element from the priority queue, and calculate the value of the function `f(n)` for each of it's neighbor
    * Remove the minimum element from the priority queue and add that to Closed List
    * The minimum element is assigned the parent of the neighbors
    * Neighbors already present in the Closed List are skipped and the ones already present in Priority Queue are updated if the value of `f(n)` is greater in the queue 
3. The parent assignment is used, to backtrack from the goal node to the start node

### Greedy Search
The Greedy Search algorithm is an extreme form of the informed search algorithms. In this, the idea is to expand the node with the smallest estimated cost to reach the goal. The cost function for the algorithm is`f(n) = h(n),`where, `h(n)` is a function that estimates the distance remaining to the goal. It can be any distance function like Euclidean Distance, Manhattan Distance and so on. They tend to find good solutions quickly, although not always the optimal ones. 

### Dijkstra's Algorithm
The goal of Dijkstra's Algorithm is to find a path where the cummulative sum of the costs is least. The cost here refers to the edges traversed starting from the start node. The cost function for the algorithm is`f(n) = g(n)`where, `g(n)` represents the cummulative cost of the path from starting node to any vertex `n`.

This makes Dijkstra's Algorithm effective for finding shortest paths as long as edges don't have a negative cost.

### A-Star
A star is a combination of the Greedy Search and Dijkstra's algorithm. By means of the weight parameter the proportional dominance of the two algorithms can be decided. It makes use of the combination of information that Dijkstra's Algorithm uses, favoring the vertices that are close to the starting point and the information that Greedy Search uses, favoring vertices close to goal. The cost function for the algorithm is:

`f(n) = g(n) + w * h(n)`

where, `h(n)` is a function that estimates the distance remaining to the goal and `g(n)` represents the exact cost of the path from starting point to vertex `n`. `w` is a tunable weight parameter.

**Different Motion Models**

<p align="middle">
    <img src="assets/astar/way_4.png" width="300" height="300"/>
    <img src="assets/astar/way_8.png" width="300" height="300"/>
</p>

*The left image shows 4 way motion model and the right image shows 8 way motion model*

**Different Values of Weight**

<p align="middle">
    <img src="assets/astar/weight_0.png" width="300" height="300"/>
    <img src="assets/astar/weight_1.png" width="300" height="300"/>
    <img src="assets/astar/weight_10.png" width="300" height="300"/>
</p>
*The first image shows 0 weight value, having a greater path length. The second image shows a weight value of 1 and the third image shows a weight value of 10. Increasing the weight value results in a reduction in path length.*

## Locally Smooth Trajectory Planning
The global path may be decomposed into a sequence of checkpoints. The objective of locally-Smooth Trajectory Planning is to provide piece-wise smooth path between given a pair of checkpoints, taking into account the initial and final heading directions of the robot. A simple means of achieving this is by using $N$-th order polynomial to interpolate all the points on the global path between two checkpoints. For $N \le 3$, the Cartesian coordinates of the points and the heading direction act as the boundary conditions to determine the coefficient of the interpolating polynomial. Interpolation results of various values of $N$ are discussed further.

### Linear Interpolation
This type of interpolation fits a straight line between any two given points. The path formed by linear interpolation is not completely smooth.  At some places, the final path contains some steep curves or have a sudden change of slope. Such change in slopes will have to be overcome by the underlying trajectory planning algorithm.

### Cubic Interpolation
This type of interpolation fits a cubic polynomial between any two given points. The Cartesian coordinates of the points and their immediate slope act as the boundary conditions for these polynomials. The path generated by cubic polynomial is relatively smoother than the one generated by Linear Interpolation. In order to account for smoothness, the final path also contains some random curves in the path which are again easily covered by trajectory Planning algorithms.

### Polynomial Interpolation
This type of interpolation fits a polynomial of one less dimension than the total number of given points. This strategy is slightly different than the preceding two as here, the curve is fitted on all points simultaneously rather than on two points in a sliding fashion.  This strategy outputs a very smooth path, however gets worse in performance and path length as the number of points increase. This algorithm is suited for paths when there are fewer number of points to interpolate on.

<p align="middle">
    <img src="assets/interpolation/linear.png" width="350" height="300"/>
    <img src="assets/interpolation/cubic.png" width="350" height="300"/>
    <img src="assets/interpolation/polynomial.png" width="350" height="300"/>
</p>

*The first image shows linear path interpolation, the second image shows cubic path interpolation and the third image shows polynomial interpolation. The start and end of all the paths show cubic polynomial generated path.*

## Trajectory tracking Algorithms
Trajectory tracking algorithms take the continuous curve generated by local-path generator and returns a series of velocity commands to follow the given trajectory, taking into account the kinematic constraints of the robot.  Typically the trajectory tracking algorithms make use of cost optimization technique to find the best possible path that satisfy the given constraints. We study two trajectory tracking algorithms in this work

### Frenet Frame Trajectory Optimization
Frenet frames describe the kinematic properties of a particle moving along a continuously differentiable curve. Instead of the Cartesian X-Y coordinates of the path to traverse, Frenet frames make use of Lateral (normal to the curve) and Longitudinal (tangent to the curve) axes to generate a trajectory for the robot to follow. 
The cost function of the algorithm focuses on minimizing the final lateral distance, the difference between the current speed and the target speed and the jerk on the robot.
The algorithm makes use of Quintic Polynomials to do the cost optimization. By varying the boundary conditions, like final velocity, time to reach, final lateral and longitudinal positions, various quintic polynomials are generated. The parameters generated from these polynomials are used to determine the magnitude of the cost function.
The trajectory giving the minimum value of cost function is choosen for the robot to follow.

**Algorithm (Velocity Keeping)**

1. Initialize the Frenet frame variables, `s`, `d` and their higher order derivatives to zero
2. Generate a set of Quintic Polynomials with initial boundary conditions with `d` and it's higher derivatives and final boundary conditions by varying the time to cover the path and final value of `d`. These polynomials are for Longitudinal Trajectory.
3. Generate a set of Quartic Polynomials with initial boundary conditions with `s` and it's higher derivates and final boundary conditions by varying the time to cover the path and final value of lateral speed `ds/dt`. These polynomials are for Lateral Trajectory.
4. Calculate the aggregate of the costs of both lateral and longitudinal polynomials. The cost functions used are:
    * `Cd = K_J * Jp + K_T * Ti + K_D * Di`, for longitudinal polynomials where `K_J`, `K_T` and `K_D` are constants and `Jp` is the sum of the square of longitudinal jerks ($d^3t/dt^3$) at each point of the trajectory,`Ti` is the total time taken for the path and `Di` is the square of the final value of `d`
    * `Cs = K_J * Js + K_T * Ti + K_D * Ds`, for lateral polynomials where `K_J`, `K_T` and `K_D` are constants and `Js` is the sum of square of lateral jerks ($d^3t/dt^3$)  at each point of trajectory, `Ti` is the total time taken for the path and `Ds` is the sum of square of the difference between the target speed and the current speed at each point of trajectory
    * `K_LAT * Cs + K_LON * Cd`, for the final cost, where `K_LAT` and `K_LON` are constants
5. Choose the trajectory having the minimum aggregate cost and take the first step of the generated trajectory
6. Regenerate and keep following the newly generated trajectories until goal position is reached

The algorithm performs very well in highway scenarios, as the algorithm automatically decides whether to move at higher speed, follow a certain car or to overtake a car, which are the three most typical use cases.
Under Gaussian noise, the Frenet frame method is robust to noise at high speeds. However, under low speeds(< 2 m/s ?), the algorithm is affected by noise, and suffers from some level of deviation from the planned path.
Also, the performance of the algorithm is affected by increasing number of possible boundary conditions. The algorithm has to deal with a larger number of polynomials with increasing possible values of the boundary conditions, resulting in greater processing times.

**Different Highway Scenarios**

<p align="middle">
    <img src="assets/frenet_frame/a1.png" width="100" height="100"/>
    <img src="assets/frenet_frame/a2.png" width="100" height="100"/>
    <img src="assets/frenet_frame/a3.png" width="100" height="100"/>
    <img src="assets/frenet_frame/a4.png" width="100" height="100"/>
    <img src="assets/frenet_frame/a5.png" width="100" height="100"/>
</p>

*The above set of images show the velocity keeping functionality of the Frenet Frame method*

<p align="middle">
    <img src="assets/frenet_frame/b1.png" width="100" height="100"/>
    <img src="assets/frenet_frame/b2.png" width="100" height="100"/>
    <img src="assets/frenet_frame/b3.png" width="100" height="100"/>
    <img src="assets/frenet_frame/b4.png" width="100" height="100"/>
    <img src="assets/frenet_frame/b5.png" width="100" height="100"/>\
    <img src="assets/frenet_frame/b6.png" width="100" height="100"/>
    <img src="assets/frenet_frame/b7.png" width="100" height="100"/>
    <img src="assets/frenet_frame/b8.png" width="100" height="100"/>
</p>

*The above set of images show the velocity keeping and the following strategies of Frenet Frame method*

**Effect of Noise**

<p align="middle">
    <img src="assets/frenet_frame/0.1.png" width="250" height="200"/>
    <img src="assets/frenet_frame/0.2.png" width="250" height="200"/>
    <img src="assets/frenet_frame/0.4.png" width="250" height="200"/>
</p>

*The above set of images show the effect of observational noise on the Frenet Frame Trajectory Planning algorithm. The leftmost image shows the effect of Gaussian Noise with standard deviation of 0.1, the middle image shows the effect of Gaussian Noise with standard deviation of 0.2 and the rightmost image shows the effect of Gaussian Noise with standard deviation of 0.4. A noise of 0.4 is very unlikely in real scenarios, hence the Frenet Frame algorithm is quite robust to noise.*

### Model Predictive Control
Model Predictive Control is a general method to determine control inputs while satisfying a set of constraints. Assuming a motion model for the vehicle, the trajectory for a Prediction horizon can be computed.  The optimization problem involves choosing the control inputs that selects the least-cost path. For the predicted optimal trajectory, the robot executes the first step on the trajectory.  This completes a single iteration of the MPC algorithm, The robot then proceeds to calculate the optimal trajectory for the next prediction horizon. This class of algorithms wherein only a section of the optimal solution is executed is referred to as receding Horizon planners
The cost function of the algorithm focuses on the deviation from the original path, difference from target velocity, angle of heading, acceleration, angular velocity and jerk.
For the optimization part, the algorithm can make use of any off-the-shelf solver. For the purpose of this work, the algorithm makes use of SLSQP (Sequential Least Squares Programming).

**Algorithm**

1. Initialize the variables, `x`, `y` and `yaw` to their initial positions and their derivatives to zero

2. Plan a trajectory by formulating the non-linear optimization problem taking into account the kinematic and possible velocity/ curvature constraints. The cost function used is 

   `K_X * Dx + K_Y * Dy + K_V * Dv + K_Yaw * Dyaw + K_A * Da + K_AY * Day + K_J * Dj`, 

   where `K_X`, `K_Y`, `K_V`, `K_Yaw`, `K_A`, `K_AY`, `K_J` are constants and `Dx` and `Dy` are squares of differences of the current cartesian to the reference cartesian points on the path. `Dv` and `Dyaw` are square of differences of the current velocity and angular velocity to the target ones. `Da`, `Day` and `Dj` are the squares of the acceleration, angular acceleration and jerk respectively.

3. Execute the first step of the planned trajectory 

4. Keep iterating the trajectory planning until the goal state is reached

This algorithm is quite robust to Gaussian noise at different speeds and follows the reference path well. At high speeds, the MPC algorithm starts to deviate slightly from the reference path in order to maintain the target speed. However, the algorithm does not explicitly avoid obstacles

**Different Target Speeds**

<p align="middle">
    <img src="assets/mpc/targetspeed_5.png" width="250" height="200"/>
    <img src="assets/mpc/targetspeed_10.png" width="250" height="200"/>
    <img src="assets/mpc/targetspeed_20.png" width="250" height="200"/>
</p>

*The leftmost image shows the tracking for target speed of 5, the middle image shows target speed of 10 and the rightmost image shows a target speed of 20. As the speed increases, the tracker tries to maintain the target speed making it slightly deviate from the reference path.*

**Effect of Noise**

<p align="middle">
    <img src="assets/mpc/0.1.png" width="250" height="200"/>
    <img src="assets/mpc/0.2.png" width="250" height="200"/>
    <img src="assets/mpc/0.3.png" width="250" height="200"/>
</p>

*The above set of images show the effect of observational noise on the MPC algorithm. The leftmost image shows the effect of Gaussian Noise with standard deviation of 0.1, the middle image shows the effect of Gaussian Noise with standard deviation of 0.2 and the rightmost image shows the effect of Gaussian Noise with standard deviation of 0.3. Even at a very high noise of 0.3 standard deviation the algorithm seems to be pretty robust.*

## Results and Analysis
- Both the Trajectory Planning algorithms are quite robust to noise and follow the reference path very well under certain conditions.

- The Frenet frame trajectory tracking method is robust to noise under higher speeds. Under low speeds the algorithm suffers from some amount of deviation under normal gaussian noise. Also, the algorithm offers an inherent obstacle avoidance mechanism.

- The Model Predictive Control algorithm is robust to noise at high as well as slow speeds. With increasing speeds, the algorithm starts deviating from the reference path. Also, the algorithm does not explicitly provide any capability to deal with dynamic obstacles.

- It may be concluded, that Frenet frame algorithm is suited for robots at higher speeds and the MPC algorithm is suited for robots under lower speeds. A particular use case for Frenet frame algorithm would be an Autonomous Car driving on highways, and for MPC algorithm would be a warehouse based robot requiring to navigate from one place to another.

## Future Work

- State-based lattice planner and Dynamic window avoidance are de-facto choices for ROS developers. Their performance can be compared with the pipeline developed here
- Currently, these algorithms only work on software based simulations, and on the pre-defined maps. The suite of algorithms can be extended to make these implementations ready for use on hardware. 

## References

- M. Werling et al, [Optimal Trajectory Generation for Dynamic Street Scenarios in a Frenet Frame](https://www.researchgate.net/publication/224156269_Optimal_Trajectory_Generation_for_Dynamic_Street_Scenarios_in_a_Frenet_Frame)

- Python Robotics by Atsushi Sakai [Github Repository](https://github.com/AtsushiSakai/PythonRobotics)

- Bench-MR [Github Repository](https://robot-motion.github.io/bench-mr/)

- Moving AI 2D [Map Dataset](https://www.movingai.com/benchmarks/grids.html)